name: Deploy Booklub Prod

on:
  push:
    branches: [ main ]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: github-actions-deploy

      - name: Install Serverless
        run: npm i -g serverless@3

      - name: Ensure Google OAuth SSM parameters exist
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          set -euo pipefail
          if ! aws ssm get-parameter --name "/bookclub/oauth/google_client_id" >/dev/null 2>&1; then
            aws ssm put-parameter \
              --name "/bookclub/oauth/google_client_id" \
              --type String \
              --value "$GOOGLE_CLIENT_ID"
          else
            echo "SSM parameter /bookclub/oauth/google_client_id already exists; not overwriting to preserve version 1"
          fi
          if ! aws ssm get-parameter --name "/bookclub/oauth/google_client_secret" --with-decryption >/dev/null 2>&1; then
            aws ssm put-parameter \
              --name "/bookclub/oauth/google_client_secret" \
              --type SecureString \
              --value "$GOOGLE_CLIENT_SECRET"
          else
            echo "SSM parameter /bookclub/oauth/google_client_secret already exists; not overwriting to preserve version 1"
          fi

      - name: Backend deps
        working-directory: bookclub-app/backend
        run: npm ci

      - name: Ollama health check (non-blocking)
        env:
          VISION_LLM_PROVIDER: ${{ vars.VISION_LLM_PROVIDER }}
          OLLAMA_ENDPOINT: ${{ secrets.OLLAMA_ENDPOINT }}
        run: |
          set +e
          if [ "${VISION_LLM_PROVIDER}" = "ollama" ] && [ -n "${OLLAMA_ENDPOINT}" ]; then
            echo "Checking Ollama endpoint: $OLLAMA_ENDPOINT"
            curl -sS --max-time 5 "$OLLAMA_ENDPOINT/api/tags" | head -c 500 || echo "(no response)"
            echo "(Non-blocking)"
          else
            echo "Skipping Ollama health check (provider=${VISION_LLM_PROVIDER}, endpoint=${OLLAMA_ENDPOINT:+set})"
          fi

      - name: Deploy backend (Serverless)
        working-directory: bookclub-app/backend
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          # LLM provider configuration via GitHub Actions secrets
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          VISION_LLM_PROVIDER: ${{ vars.VISION_LLM_PROVIDER }}
          OLLAMA_ENDPOINT: ${{ secrets.OLLAMA_ENDPOINT }}
          OLLAMA_MODEL: ${{ secrets.OLLAMA_MODEL }}
        run: npx serverless deploy --stage prod

      - name: Diagnostics CFN state and Serverless info (non-blocking)
        working-directory: bookclub-app/backend
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          set +e
          echo "=== CFN: describe-stacks (bookclub-app-prod) ==="
          aws cloudformation describe-stacks --stack-name bookclub-app-prod --output table
          echo "\n=== CFN: recent stack events (bookclub-app-prod) ==="
          aws cloudformation describe-stack-events --stack-name bookclub-app-prod --max-items 25 --output table
          echo "\n=== Serverless info (prod) ==="
          npx serverless info --stage prod --verbose || true

      - name: Check CloudFormation stack status
        working-directory: bookclub-app/backend
        run: |
          set -euo pipefail
          STACK_NAME="bookclub-app-prod"
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text || echo "")
          echo "StackStatus=$STATUS"
          if [ -z "$STATUS" ]; then
            echo "Stack $STACK_NAME not found. The deploy step may have failed before stack creation." >&2
            exit 1
          fi
          case "$STATUS" in
            *_IN_PROGRESS) echo "Stack update in progress; continuing" ;;
            *_COMPLETE) echo "Stack is complete: $STATUS" ;;
            *)
              echo "Stack is in error state: $STATUS" >&2
              echo "Recent events:" >&2
              aws cloudformation describe-stack-events --stack-name "$STACK_NAME" --max-items 15 --output table || true
              exit 1
              ;;
          esac

      - name: Detect API URL (prefer custom domain, fallback to execute-api)
        id: detect_api
        working-directory: bookclub-app/backend
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          set -euo pipefail
          # 1) Prefer CFN Outputs.ServiceEndpoint
          EXEC_API=$(aws cloudformation describe-stacks --stack-name bookclub-app-prod \
            --query "Stacks[0].Outputs[?OutputKey=='ServiceEndpoint'].OutputValue | [0]" --output text 2>/dev/null | sed 's/None//')
          # 2) Fallback to serverless info (ensure env for variable resolution)
          if [ -z "${EXEC_API}" ]; then
            EXEC_API=$(npx serverless info --stage prod --verbose | awk '/ServiceEndpoint:/{print $2; exit}' || echo "")
          fi
          if [ -z "$EXEC_API" ]; then
            echo "serverless info did not return a ServiceEndpoint; attempting CloudFormation export fallback..."
            REST_API_ID=$(aws cloudformation list-exports --query "Exports[?Name=='bookclub-app-prod-RestApiId'].Value | [0]" --output text || echo "")
            if [ -n "$REST_API_ID" ] && [ "$REST_API_ID" != "None" ]; then
              EXEC_API="https://${REST_API_ID}.execute-api.${AWS_REGION}.amazonaws.com/prod"
              echo "Constructed EXEC_API from export: $EXEC_API"
            else
              echo "Failed to detect ServiceEndpoint from both 'serverless info' and CFN exports."
              echo "Check the 'Deploy backend (Serverless)' step above for errors, or verify AWS credentials/role."
              exit 1
            fi
          fi
          CUSTOM_DOMAIN=${{ env.AWS_REGION }}
          # Custom API domain from app config
          CUSTOM_DOMAIN=$(jq -r '.apiCustomDomain // ""' config/app.prod.json)
          if [ -n "$CUSTOM_DOMAIN" ] && host "$CUSTOM_DOMAIN" >/dev/null 2>&1; then
            API_URL="https://$CUSTOM_DOMAIN"
          else
            API_URL="$EXEC_API"
          fi
          echo "API_URL=$API_URL" | tee -a "$GITHUB_ENV"

      - name: Fetch Cognito IDs from CloudFormation exports
        working-directory: bookclub-app/backend
        run: |
          set -euo pipefail
          SERVICE=bookclub-app
          STAGE=prod
          # Try CFN exports first (may print 'None' when missing)
          USER_POOL_ID=$(aws cloudformation list-exports --query "Exports[?Name=='${SERVICE}-${STAGE}-UserPoolId'].Value | [0]" --output text | sed 's/None//')
          CLIENT_ID=$(aws cloudformation list-exports --query "Exports[?Name=='${SERVICE}-${STAGE}-UserPoolClientId'].Value | [0]" --output text | sed 's/None//')

          # If exports missing, fall back to resolving from stack resources + Cognito APIs
          if [ -z "$USER_POOL_ID" ] || [ -z "$CLIENT_ID" ]; then
            echo "CFN exports for UserPoolId/ClientId not found; falling back to stack resources..."
            # Find the physical user pool id from the stack resources
            USER_POOL_ID=${USER_POOL_ID:-$(aws cloudformation describe-stack-resources \
              --stack-name "${SERVICE}-${STAGE}" \
              --query "StackResources[?LogicalResourceId=='UserPool'].PhysicalResourceId | [0]" --output text 2>/dev/null | sed 's/None//')}

            if [ -n "$USER_POOL_ID" ]; then
              # Try to find an app client by name first, then default to the first client
              CLIENT_NAME="${SERVICE}-client-${STAGE}"
              CLIENT_ID=${CLIENT_ID:-$(aws cognito-idp list-user-pool-clients --user-pool-id "$USER_POOL_ID" --max-results 60 \
                --query "UserPoolClients[?ClientName=='${CLIENT_NAME}'].ClientId | [0]" --output text 2>/dev/null | sed 's/None//')}
              if [ -z "$CLIENT_ID" ] || [ "$CLIENT_ID" = "None" ]; then
                CLIENT_ID=$(aws cognito-idp list-user-pool-clients --user-pool-id "$USER_POOL_ID" --max-results 60 \
                  --query "UserPoolClients[0].ClientId" --output text 2>/dev/null | sed 's/None//')
              fi
            fi
          fi

          if [ -z "$USER_POOL_ID" ] || [ -z "$CLIENT_ID" ]; then
            echo "Failed to resolve Cognito UserPoolId/ClientId from both CFN exports and Cognito APIs." >&2
            echo "Check that the Serverless stack created the User Pool and App Client successfully." >&2
            exit 1
          fi
          DOMAIN_PREFIX=$(jq -r '.userPoolDomainPrefix' config/app.prod.json)
          COGNITO_DOMAIN="${DOMAIN_PREFIX}-${STAGE}.auth.${AWS_REGION}.amazoncognito.com"
          echo "REACT_APP_COGNITO_USER_POOL_ID=$USER_POOL_ID" >> "$GITHUB_ENV"
          echo "REACT_APP_COGNITO_CLIENT_ID=$CLIENT_ID" >> "$GITHUB_ENV"
          echo "REACT_APP_COGNITO_DOMAIN=$COGNITO_DOMAIN" >> "$GITHUB_ENV"

      - name: Build frontend
        working-directory: bookclub-app/frontend
        env:
          # Do not fail the production build on warnings
          CI: false
          # Prefer detected API URL; falls back to execute-api if custom domain not live yet
          REACT_APP_API_URL: ${{ env.API_URL }}
          REACT_APP_COGNITO_REGION: us-east-1
          # Optional: You can fetch these dynamically via serverless info if desired
          # For simplicity in CI, you may store them as secrets
          REACT_APP_COGNITO_USER_POOL_ID: ${{ env.REACT_APP_COGNITO_USER_POOL_ID }}
          REACT_APP_COGNITO_CLIENT_ID: ${{ env.REACT_APP_COGNITO_CLIENT_ID }}
          REACT_APP_COGNITO_DOMAIN: ${{ env.REACT_APP_COGNITO_DOMAIN }}
          REACT_APP_OAUTH_REDIRECT_SIGNIN: https://booklub.shop/auth/callback
          REACT_APP_OAUTH_REDIRECT_SIGNOUT: https://booklub.shop/
          REACT_APP_OAUTH_SCOPES: "openid email profile"
          REACT_APP_OAUTH_RESPONSE_TYPE: code
        run: |
          npm ci
          npm run build

      - name: Ensure frontend S3 bucket exists
        env:
          FRONTEND_S3_BUCKET: ${{ secrets.FRONTEND_S3_BUCKET }}
        run: |
          set -euo pipefail
          if aws s3api head-bucket --bucket "$FRONTEND_S3_BUCKET" 2>/dev/null; then
            echo "Frontend bucket exists: $FRONTEND_S3_BUCKET"
          else
            echo "Creating frontend bucket: $FRONTEND_S3_BUCKET"
            aws s3api create-bucket --bucket "$FRONTEND_S3_BUCKET" --region $AWS_REGION \
              $( [ "$AWS_REGION" = "us-east-1" ] || echo --create-bucket-configuration LocationConstraint=$AWS_REGION )
          fi

      - name: Upload frontend to S3
        run: |
          aws s3 sync bookclub-app/frontend/build s3://${{ secrets.FRONTEND_S3_BUCKET }} --delete

      - name: Configure CloudFront SPA error responses (403/404 -> /index.html)
        env:
          DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          set -euo pipefail
          id="$DISTRIBUTION_ID"
          # Fetch current distribution config and ETag
          aws cloudfront get-distribution-config --id "$id" --output json > cfg.json
          etag=$(jq -r '.ETag' cfg.json)
          # Build updated DistributionConfig with SPA error responses
          jq '.DistributionConfig
            | .DefaultRootObject = "index.html"
            | .CustomErrorResponses = (.CustomErrorResponses // {Quantity:0, Items:[]})
            | .CustomErrorResponses.Items = ((.CustomErrorResponses.Items // [])
                | map(select(.ErrorCode != 403 and .ErrorCode != 404))
                + [
                    {"ErrorCode":403, "ResponsePagePath":"/index.html", "ResponseCode":"200", "ErrorCachingMinTTL":0},
                    {"ErrorCode":404, "ResponsePagePath":"/index.html", "ResponseCode":"200", "ErrorCachingMinTTL":0}
                  ])
            | .CustomErrorResponses.Quantity = (.CustomErrorResponses.Items | length)
          ' cfg.json > distconfig.json
          aws cloudfront update-distribution --id "$id" --if-match "$etag" --distribution-config file://distconfig.json

      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
